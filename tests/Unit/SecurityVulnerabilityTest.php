<?php

use Illuminate\Http\Request;
use KenDeNigerian\PayZephyr\DataObjects\ChargeRequestDTO;
use KenDeNigerian\PayZephyr\Exceptions\DriverNotFoundException;
use KenDeNigerian\PayZephyr\Facades\Payment;
use KenDeNigerian\PayZephyr\Http\Controllers\WebhookController;
use KenDeNigerian\PayZephyr\PaymentManager;

test('charge request prevents sql injection in email field', function () {
    $maliciousEmail = "test@example.com'; DROP TABLE users; --";

    // Email validation will fail, but that's expected
    expect(fn () => ChargeRequestDTO::fromArray([
        'amount' => 1000,
        'currency' => 'NGN',
        'email' => $maliciousEmail,
    ]))->toThrow(\InvalidArgumentException::class, 'Invalid email address');
});

test('charge request prevents sql injection in reference field', function () {
    $maliciousReference = "REF_123'; DROP TABLE payment_transactions; --";

    $request = ChargeRequestDTO::fromArray([
        'amount' => 1000,
        'currency' => 'NGN',
        'email' => 'test@example.com',
        'reference' => $maliciousReference,
    ]);

    // Should not throw SQL error
    expect($request->reference)->toBe($maliciousReference);
});

test('webhook controller prevents sql injection in reference extraction', function () {
    $maliciousPayload = [
        'data' => [
            'reference' => "REF_123'; DROP TABLE payment_transactions; --",
        ],
    ];

    $controller = new WebhookController(app(PaymentManager::class));
    $reflection = new \ReflectionClass($controller);
    $method = $reflection->getMethod('extractReference');
    $method->setAccessible(true);

    $reference = $method->invoke($controller, 'paystack', $maliciousPayload);

    // Eloquent should handle escaping
    expect($reference)->toBeString();
});

test('webhook controller validates signature before processing', function () {
    config([
        'payments.webhook.verify_signature' => true,
        'payments.providers.paystack' => [
            'driver' => 'paystack',
            'secret_key' => 'sk_test_xxx',
            'enabled' => true,
        ],
    ]);

    $request = Request::create('/payments/webhook/paystack', 'POST', [
        'data' => ['reference' => 'test_ref'],
    ]);

    // Invalid signature
    $request->headers->set('x-paystack-signature', 'invalid_signature');

    $driver = Mockery::mock(\KenDeNigerian\PayZephyr\Contracts\DriverInterface::class);
    $driver->shouldReceive('validateWebhook')->andReturn(false);

    $manager = Mockery::mock(PaymentManager::class);
    $manager->shouldReceive('driver')->andReturn($driver);

    $controller = new WebhookController($manager);
    $response = $controller->handle($request, 'paystack');

    expect($response->getStatusCode())->toBe(403);
});

test('webhook controller rejects webhook without signature when verification enabled', function () {
    config([
        'payments.webhook.verify_signature' => true,
        'payments.providers.paystack' => [
            'driver' => 'paystack',
            'secret_key' => 'sk_test_xxx',
            'enabled' => true,
        ],
    ]);

    $request = Request::create('/payments/webhook/paystack', 'POST', [
        'data' => ['reference' => 'test_ref'],
    ]);

    // No signature header
    $driver = Mockery::mock(\KenDeNigerian\PayZephyr\Contracts\DriverInterface::class);
    $driver->shouldReceive('validateWebhook')->andReturn(false);

    $manager = Mockery::mock(PaymentManager::class);
    $manager->shouldReceive('driver')->andReturn($driver);

    $controller = new WebhookController($manager);
    $response = $controller->handle($request, 'paystack');

    expect($response->getStatusCode())->toBe(403);
});

test('payment manager prevents driver enumeration via exception messages', function () {
    config([
        'payments.providers' => [],
    ]);

    $manager = new PaymentManager;

    try {
        $manager->driver('nonexistent');
    } catch (DriverNotFoundException $e) {
        // Exception message should not reveal internal structure
        expect($e->getMessage())->not->toContain('config')
            ->and($e->getMessage())->not->toContain('providers');
    }
});

test('charge request validates email format', function () {
    $invalidEmails = [
        'not-an-email',
        '@example.com',
        'test@',
        'test..test@example.com',
        '',
    ];

    foreach ($invalidEmails as $email) {
        try {
            $request = ChargeRequestDTO::fromArray([
                'amount' => 1000,
                'currency' => 'NGN',
                'email' => $email,
            ]);

            // If validation passes, email should still be stored
            // Real validation should happen at application level
            expect($request->email)->toBe($email);
        } catch (\Exception $e) {
            // If validation fails, that's also acceptable
            expect($e)->toBeInstanceOf(\Exception::class);
        }
    }
});

test('charge request prevents negative amounts', function () {
    expect(fn () => ChargeRequestDTO::fromArray([
        'amount' => -1000,
        'currency' => 'NGN',
        'email' => 'test@example.com',
    ]))->toThrow(\Exception::class);
});

test('charge request prevents zero amount', function () {
    expect(fn () => ChargeRequestDTO::fromArray([
        'amount' => 0,
        'currency' => 'NGN',
        'email' => 'test@example.com',
    ]))->toThrow(\Exception::class);
});

test('charge request prevents extremely large amounts', function () {
    $largeAmount = PHP_INT_MAX;

    // Should handle large amounts gracefully
    try {
        $request = ChargeRequestDTO::fromArray([
            'amount' => $largeAmount,
            'currency' => 'NGN',
            'email' => 'test@example.com',
        ]);

        expect($request->amount)->toBe($largeAmount);
    } catch (\Exception $e) {
        // If validation fails for extremely large amounts, that's acceptable
        expect($e)->toBeInstanceOf(\Exception::class);
    }
});

test('webhook controller prevents xss in payload', function () {
    $xssPayload = [
        'data' => [
            'reference' => '<script>alert("xss")</script>',
        ],
    ];

    $controller = new WebhookController(app(PaymentManager::class));
    $reflection = new \ReflectionClass($controller);
    $method = $reflection->getMethod('extractReference');
    $method->setAccessible(true);

    $reference = $method->invoke($controller, 'paystack', $xssPayload);

    // Should extract reference without executing script
    expect($reference)->toBe('<script>alert("xss")</script>'); // Raw value, but should be escaped when used
});

test('payment manager does not expose sensitive data in logs', function () {
    config([
        'payments.providers.paystack' => [
            'driver' => 'paystack',
            'secret_key' => 'sk_live_secret_key_12345',
            'enabled' => true,
        ],
    ]);

    $manager = new PaymentManager;

    // Exception message should not contain secret keys
    try {
        $manager->driver('nonexistent');
    } catch (DriverNotFoundException $e) {
        $message = $e->getMessage();
        // Check that exception message doesn't contain secret keys
        expect($message)->not->toContain('sk_live_secret_key_12345');
    }
});

test('webhook controller does not expose sensitive headers in error responses', function () {
    config([
        'payments.webhook.verify_signature' => true,
        'payments.providers.paystack' => [
            'driver' => 'paystack',
            'secret_key' => 'sk_live_secret_key_12345',
            'enabled' => true,
        ],
    ]);

    $request = Request::create('/payments/webhook/paystack', 'POST', []);
    $request->headers->set('x-paystack-signature', 'signature_123');
    $request->headers->set('authorization', 'Bearer secret_token');

    $driver = Mockery::mock(\KenDeNigerian\PayZephyr\Contracts\DriverInterface::class);
    $driver->shouldReceive('validateWebhook')->andReturn(false);

    $manager = Mockery::mock(PaymentManager::class);
    $manager->shouldReceive('driver')->andReturn($driver);

    $controller = new WebhookController($manager);
    $response = $controller->handle($request, 'paystack');

    // Response should not contain sensitive headers
    $responseContent = $response->getContent();
    expect($responseContent)->not->toContain('secret_token')
        ->and($responseContent)->not->toContain('sk_live_secret_key_12345');
});

test('charge request prevents path traversal in callback url', function () {
    $maliciousUrls = [
        '../../../etc/passwd',
        'file:///etc/passwd',
        'javascript:alert(1)',
    ];

    foreach ($maliciousUrls as $url) {
        try {
            $request = ChargeRequestDTO::fromArray([
                'amount' => 1000,
                'currency' => 'NGN',
                'email' => 'test@example.com',
                'callback_url' => $url,
            ]);

            // URL should be stored but validated by provider
            expect($request->callbackUrl)->toBe($url);
        } catch (\Exception $e) {
            // If validation fails, that's acceptable
            expect($e)->toBeInstanceOf(\Exception::class);
        }
    }
});

test('payment manager prevents provider enumeration', function () {
    config([
        'payments.providers' => [
            'paystack' => ['enabled' => true, 'driver' => 'paystack', 'secret_key' => 'test'],
            'stripe' => ['enabled' => false, 'driver' => 'stripe', 'secret_key' => 'test'],
        ],
    ]);

    $manager = new PaymentManager;

    // Should not reveal which providers exist
    try {
        $manager->driver('unknown_provider');
    } catch (DriverNotFoundException $e) {
        $message = $e->getMessage();
        // Should not reveal list of available providers
        expect($message)->not->toContain('paystack')
            ->and($message)->not->toContain('stripe');
    }
});

test('webhook controller handles malformed json gracefully', function () {
    config([
        'payments.webhook.verify_signature' => false,
        'payments.providers.paystack' => [
            'driver' => 'paystack',
            'secret_key' => 'sk_test_xxx',
            'enabled' => true,
        ],
    ]);

    $request = Request::create('/payments/webhook/paystack', 'POST');
    $request->headers->set('Content-Type', 'application/json');
    $request->merge([]); // Empty payload

    $controller = new WebhookController(app(PaymentManager::class));

    // Should handle gracefully without throwing
    try {
        $response = $controller->handle($request, 'paystack');
        expect($response->getStatusCode())->toBeIn([200, 500]);
    } catch (\Exception $e) {
        // If exception is thrown, it should be caught internally
        expect($e)->toBeInstanceOf(\Exception::class);
    }
});

test('charge request prevents command injection in metadata', function () {
    $maliciousMetadata = [
        'order_id' => '123; rm -rf /',
        'description' => 'test && cat /etc/passwd',
    ];

    $request = ChargeRequestDTO::fromArray([
        'amount' => 1000,
        'currency' => 'NGN',
        'email' => 'test@example.com',
        'metadata' => $maliciousMetadata,
    ]);

    // Metadata should be stored as-is but not executed
    expect($request->metadata)->toBe($maliciousMetadata);
});

test('payment manager prevents timing attacks in driver resolution', function () {
    config([
        'payments.providers.paystack' => [
            'driver' => 'paystack',
            'secret_key' => 'sk_test_xxx',
            'enabled' => true,
        ],
    ]);

    $manager = new PaymentManager;

    // Both should take similar time (or throw similar exceptions)
    $start1 = microtime(true);
    try {
        $manager->driver('paystack');
    } catch (\Exception $e) {
        // Ignore
    }
    $time1 = microtime(true) - $start1;

    $start2 = microtime(true);
    try {
        $manager->driver('nonexistent');
    } catch (\Exception $e) {
        // Ignore
    }
    $time2 = microtime(true) - $start2;

    // Times should be reasonably close (within 10x)
    // This is a basic check, real timing attack prevention requires more sophisticated measures
    expect($time2)->toBeLessThan($time1 * 10);
});

